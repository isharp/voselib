<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Data Stuctures Library: include/sllist.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Data Stuctures Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sllist.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Stuctures and functions for a singly-linked list API.  
<a href="#details">More...</a></p>

<p><a href="sllist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a31ad4237b7bfcb9d94070c5867f6ed5c"><td class="memItemLeft" align="right" valign="top">struct sllist *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a31ad4237b7bfcb9d94070c5867f6ed5c">sllist_create</a> (void)</td></tr>
<tr class="separator:a31ad4237b7bfcb9d94070c5867f6ed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ddcfd0f34a9256fdcfb5f483821a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a29ddcfd0f34a9256fdcfb5f483821a77">sllist_destroy</a> (struct sllist *sllist)</td></tr>
<tr class="separator:a29ddcfd0f34a9256fdcfb5f483821a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a211259de8570cb9254f38a75e52024"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a8a211259de8570cb9254f38a75e52024">sllist_push_front</a> (struct sllist *sllist, void *data)</td></tr>
<tr class="separator:a8a211259de8570cb9254f38a75e52024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b1692846d312ea2856084cd8b6f323"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a12b1692846d312ea2856084cd8b6f323">sllist_push_back</a> (struct sllist *sllist, void *data)</td></tr>
<tr class="separator:a12b1692846d312ea2856084cd8b6f323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e829be146710556cce63ee83c932dd9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a7e829be146710556cce63ee83c932dd9">sllist_step</a> (struct sllist *sllist)</td></tr>
<tr class="separator:a7e829be146710556cce63ee83c932dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f74989b604470a4104fbe9fe0e1d18"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a97f74989b604470a4104fbe9fe0e1d18">sllist_read</a> (struct sllist *sllist, int index)</td></tr>
<tr class="separator:a97f74989b604470a4104fbe9fe0e1d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d5c3c185f5e8005ed079a67932f96f"><td class="memItemLeft" align="right" valign="top">struct lnode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#af5d5c3c185f5e8005ed079a67932f96f">sllist_find</a> (struct sllist *sllist, int index)</td></tr>
<tr class="separator:af5d5c3c185f5e8005ed079a67932f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b697791950b000bc5a53f2d2cd2ba0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#aa6b697791950b000bc5a53f2d2cd2ba0">sllist_insert_after</a> (struct sllist *sllist, struct lnode *lnode, void *data)</td></tr>
<tr class="separator:aa6b697791950b000bc5a53f2d2cd2ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522e0dc90783f10dea07df8ad997bffd"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a522e0dc90783f10dea07df8ad997bffd">sllist_pop_front</a> (struct sllist *sllist)</td></tr>
<tr class="separator:a522e0dc90783f10dea07df8ad997bffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b91139752ed0d37019b835bbf1f6a7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#ad1b91139752ed0d37019b835bbf1f6a7">sllist_pop_back</a> (struct sllist *sllist)</td></tr>
<tr class="separator:ad1b91139752ed0d37019b835bbf1f6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb870c7c53b316f63591965bda25ec6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a4eb870c7c53b316f63591965bda25ec6">sllist_extract_after</a> (struct sllist *sllist, struct lnode *lnode)</td></tr>
<tr class="separator:a4eb870c7c53b316f63591965bda25ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1258baec909fd4656e19c5dff55ee7f8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#a1258baec909fd4656e19c5dff55ee7f8">sllist_read_front</a> (struct sllist *sllist)</td></tr>
<tr class="separator:a1258baec909fd4656e19c5dff55ee7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65a4a55d407992249babcde7ef87ee5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sllist_8h.html#ac65a4a55d407992249babcde7ef87ee5">sllist_read_back</a> (struct sllist *sllist)</td></tr>
<tr class="separator:ac65a4a55d407992249babcde7ef87ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stuctures and functions for a singly-linked list API. </p>
<p>The API presented here is intended to be an opaque implementation. The user is provided with several different functions to manipulate lists and their contents. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a31ad4237b7bfcb9d94070c5867f6ed5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sllist* sllist_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new list.</p>
<p>Returns a pointer to a new, empty list. If allocation fails, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a29ddcfd0f34a9256fdcfb5f483821a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sllist_destroy </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a list.</p>
<p>Frees the memory of the list struct and all associated nodes. </p>

</div>
</div>
<a class="anchor" id="a4eb870c7c53b316f63591965bda25ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_extract_after </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lnode *&#160;</td>
          <td class="paramname"><em>lnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a specified node.</p>
<p>Remove the specified node from the linked list, save a pointer to the data, free the node (but do not free the data itself), and return a pointer to the data so that it can be used. If the list is empty or the node doesn't exist in the list, returns NULL. </p>

</div>
</div>
<a class="anchor" id="af5d5c3c185f5e8005ed079a67932f96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lnode* sllist_find </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain a pointer to a node by index.</p>
<p>Returns a pointer to the node at the location specified by the passed index value. The passed index value is interpreted as an offset from index zero, the first node of the list. Returns NULL if the list is empty or the index is out of range. </p>

</div>
</div>
<a class="anchor" id="aa6b697791950b000bc5a53f2d2cd2ba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sllist_insert_after </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lnode *&#160;</td>
          <td class="paramname"><em>lnode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a node after a specified node.</p>
<p>Adds a node after the passed node. If allocation fails, returns -1, otherwise returns 0. </p>

</div>
</div>
<a class="anchor" id="ad1b91139752ed0d37019b835bbf1f6a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_pop_back </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the last node.</p>
<p>Remove the last node from the linked list, save a pointer to the data, free the node (but do not free the data itself), and return a pointer to the data so that it can be used. If the list is empty or the node doesn't exist in the list, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a522e0dc90783f10dea07df8ad997bffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_pop_front </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the first node.</p>
<p>Remove the first node from the linked list, save a pointer to the data, free the node (but do not free the data itself), and return a pointer to the data so that it can be used. If the list is empty or the node doesn't exist in the list, returns NULL. </p>

</div>
</div>
<a class="anchor" id="a12b1692846d312ea2856084cd8b6f323"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sllist_push_back </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append node to a list.</p>
<p>Adds a node to the end of the list. If allocation fails, returns -1, otherwise returns 0. </p>

</div>
</div>
<a class="anchor" id="a8a211259de8570cb9254f38a75e52024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sllist_push_front </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepend a node to the list:</p>
<p>Adds a node to the front of the list. If allocation fails, returns -1, otherwise returns 0. </p>

</div>
</div>
<a class="anchor" id="a97f74989b604470a4104fbe9fe0e1d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_read </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access data by index.</p>
<p>Returns a pointer to the payload of the node at the location specified by the passed index value. The passed index value is interpreted as an offset from index zero, the first node of the list. Returns NULL if the list is empty or the index is out of range. </p>

</div>
</div>
<a class="anchor" id="ac65a4a55d407992249babcde7ef87ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_read_back </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access data of the last node.</p>
<p>Returns a pointer to the data field of the last node. If the list is empty, the function returns NULL. </p>

</div>
</div>
<a class="anchor" id="a1258baec909fd4656e19c5dff55ee7f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* sllist_read_front </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access data of the first node.</p>
<p>Returns a pointer to the data field of the first node. If the list is empty, the function returns NULL. </p>

</div>
</div>
<a class="anchor" id="a7e829be146710556cce63ee83c932dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sllist_step </td>
          <td>(</td>
          <td class="paramtype">struct sllist *&#160;</td>
          <td class="paramname"><em>sllist</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Step through a list.</p>
<p>Changes the current node to the node after the current node. Returns 1 if stepping is impossible, such as when the current node is NULL or at the very end of the list. Otherwise, returns 0. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 20 2013 15:39:59 for Data Stuctures Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
